import { GoogleGenerativeAI } from '@google/generative-ai';
import { promises as fs } from 'fs';
import { join } from 'path';
import { v4 as uuidv4 } from 'uuid';
import { config } from '../config.js';
import { RestaurantModel, NoteModel, ReviewModel, ReviewDigestModel } from '../db/models/index.js';

const genAI = new GoogleGenerativeAI(config.geminiApiKey);

/**
 * Image generator using Gemini and Imagen models
 */
export class ImageGenerator {
  constructor() {
    // Gemini for structured graphics (menus, social posts with text)
    this.geminiModelId = 'gemini-3-pro-image-preview';
    this.geminiModel = genAI.getGenerativeModel({
      model: this.geminiModelId,
      generationConfig: {
        responseModalities: ['TEXT', 'IMAGE']
      }
    });

    // Imagen 3 for creative/artistic images
    this.imagenModelId = 'imagen-3.0-generate-002';
    this.imagenModel = genAI.getGenerativeModel({
      model: this.imagenModelId
    });
  }

  /**
   * Generate an image from a text prompt using Gemini
   */
  async generate(prompt, options = {}) {
    const {
      aspectRatio = '1:1',  // 1:1, 2:3, 3:2, 3:4, 4:3, 4:5, 5:4, 9:16, 16:9, 21:9
      outputPath = null,
      model = 'gemini'  // 'gemini' or 'imagen'
    } = options;

    if (model === 'imagen') {
      return this.generateWithImagen(prompt, options);
    }

    const fullPrompt = `${prompt}\n\nAspect ratio: ${aspectRatio}`;

    const result = await this.geminiModel.generateContent(fullPrompt);
    const response = result.response;

    // Extract image from response
    for (const part of response.candidates[0].content.parts) {
      if (part.inlineData) {
        const imageData = Buffer.from(part.inlineData.data, 'base64');

        if (outputPath) {
          await fs.writeFile(outputPath, imageData);
          return { path: outputPath, mimeType: part.inlineData.mimeType, model: 'gemini' };
        }

        return {
          data: imageData,
          base64: part.inlineData.data,
          mimeType: part.inlineData.mimeType,
          model: 'gemini'
        };
      }
    }

    throw new Error('No image generated in response');
  }

  /**
   * Generate an image using Imagen 3 (best for photorealistic/artistic images)
   * Falls back to Gemini if Imagen is unavailable
   */
  async generateWithImagen(prompt, options = {}) {
    const {
      aspectRatio = '1:1',
      outputPath = null,
      numberOfImages = 1,
      negativePrompt = null
    } = options;

    try {
      // Try Imagen 3 first
      const generationConfig = {
        numberOfImages,
        aspectRatio
      };

      if (negativePrompt) {
        generationConfig.negativePrompt = negativePrompt;
      }

      const result = await this.imagenModel.generateImages(prompt, generationConfig);

      if (!result.images || result.images.length === 0) {
        throw new Error('No images generated by Imagen');
      }

      const image = result.images[0];
      const imageData = Buffer.from(image.bytesBase64Encoded, 'base64');
      const mimeType = image.mimeType || 'image/png';

      if (outputPath) {
        await fs.writeFile(outputPath, imageData);
        return { path: outputPath, mimeType, model: 'imagen' };
      }

      return {
        data: imageData,
        base64: image.bytesBase64Encoded,
        mimeType,
        model: 'imagen'
      };
    } catch (error) {
      console.warn(`Imagen generation failed, falling back to Gemini: ${error.message}`);

      // Fallback to Gemini with enhanced prompt for photorealistic style
      const enhancedPrompt = `Create a photorealistic, high-quality image: ${prompt}

Style: Professional photography, sharp details, natural lighting, artistic composition.
Aspect ratio: ${aspectRatio}`;

      const result = await this.geminiModel.generateContent(enhancedPrompt);
      const response = result.response;

      for (const part of response.candidates[0].content.parts) {
        if (part.inlineData) {
          const imageData = Buffer.from(part.inlineData.data, 'base64');

          if (outputPath) {
            await fs.writeFile(outputPath, imageData);
            return { path: outputPath, mimeType: part.inlineData.mimeType, model: 'gemini-fallback' };
          }

          return {
            data: imageData,
            base64: part.inlineData.data,
            mimeType: part.inlineData.mimeType,
            model: 'gemini-fallback'
          };
        }
      }

      throw new Error('No image generated');
    }
  }

  /**
   * Generate creative/artistic image (uses Imagen 3)
   * Best for: food photography, artistic shots, realistic images
   */
  async generateCreative(prompt, options = {}) {
    const restaurant = options.restaurantId
      ? RestaurantModel.getFullData(options.restaurantId)
      : null;

    let enhancedPrompt = prompt;

    if (restaurant) {
      const reviewContext = options.restaurantId ? this.getReviewContext(options.restaurantId) : null;
      const ratingNote = reviewContext?.hasReviews && reviewContext.avgRating
        ? `, rated ${reviewContext.avgRating}/5`
        : '';

      enhancedPrompt = `${prompt}

Style context: ${restaurant.cuisine_type || 'restaurant'} cuisine, brand color ${restaurant.primary_color || '#2563eb'}${ratingNote}`;
    }

    const outputPath = options.outputPath || join(
      config.paths.images,
      `creative_${options.restaurantId || 'gen'}_${Date.now()}.png`
    );

    return this.generateWithImagen(enhancedPrompt, {
      ...options,
      outputPath
    });
  }

  /**
   * Generate a social media graphic for a restaurant
   */
  async generateSocialPost(restaurantId, options = {}) {
    const {
      platform = 'instagram',  // instagram, facebook, twitter, story
      theme = 'promotion',     // promotion, announcement, menu-highlight, holiday
      customText = null
    } = options;

    const restaurant = RestaurantModel.getFullData(restaurantId);
    if (!restaurant) throw new Error('Restaurant not found');

    const activeNotes = NoteModel.getActive(restaurantId);
    const reviewContext = this.getReviewContext(restaurantId);
    const reviewBlock = this.formatReviewPromptBlock(reviewContext);

    const aspectRatios = {
      instagram: '1:1',
      facebook: '16:9',
      twitter: '16:9',
      story: '9:16'
    };

    const prompt = this.buildSocialPrompt(restaurant, {
      platform,
      theme,
      customText,
      notes: activeNotes,
      reviewBlock
    });

    const outputPath = join(
      config.paths.images,
      `${restaurantId}_social_${platform}_${Date.now()}.png`
    );

    return this.generate(prompt, {
      aspectRatio: aspectRatios[platform] || '1:1',
      outputPath
    });
  }

  /**
   * Generate a menu image/graphic
   */
  async generateMenuGraphic(restaurantId, options = {}) {
    const {
      style = 'elegant',  // elegant, casual, bold, minimal
      includePhotos = false,
      category = null  // specific category or null for full menu
    } = options;

    const restaurant = RestaurantModel.getFullData(restaurantId);
    if (!restaurant) throw new Error('Restaurant not found');

    const reviewContext = this.getReviewContext(restaurantId);
    const reviewBlock = this.formatReviewPromptBlock(reviewContext);

    const menuItems = category
      ? restaurant.menu.filter(c => c.name.toLowerCase().includes(category.toLowerCase()))
      : restaurant.menu;

    const prompt = `Create a beautiful ${style} restaurant menu graphic for "${restaurant.name}".

RESTAURANT:
- Name: ${restaurant.name}
- Cuisine: ${restaurant.cuisine_type || 'Restaurant'}
- Brand Color: ${restaurant.primary_color || '#2563eb'}
${reviewBlock}
MENU ITEMS:
${menuItems.map(cat => `
${cat.name}:
${cat.items.map(item => `  - ${item.name}: $${item.price || 'Market Price'}${item.description ? ` - ${item.description}` : ''}`).join('\n')}
`).join('\n')}

DESIGN REQUIREMENTS:
- Professional restaurant menu design
- Clear hierarchy with category headers
- Prices aligned and easy to read
- Match the ${style} aesthetic
- Use the brand color as accent
- High contrast, readable text
- ${restaurant.cuisine_type ? `Design should reflect ${restaurant.cuisine_type} cuisine style` : ''}`;

    const outputPath = join(
      config.paths.images,
      `${restaurantId}_menu_${style}_${Date.now()}.png`
    );

    return this.generate(prompt, {
      aspectRatio: '3:4',  // Portrait for menu
      outputPath
    });
  }

  /**
   * Generate a promotional flyer/graphic
   */
  async generatePromoGraphic(restaurantId, options = {}) {
    const {
      promoText = null,       // e.g., "20% off this weekend!"
      eventName = null,       // e.g., "Wine Wednesday"
      date = null,
      style = 'vibrant'
    } = options;

    const restaurant = RestaurantModel.getFullData(restaurantId);
    if (!restaurant) throw new Error('Restaurant not found');

    const reviewContext = this.getReviewContext(restaurantId);
    const reviewBlock = this.formatReviewPromptBlock(reviewContext);

    const prompt = `Create an eye-catching promotional graphic for "${restaurant.name}".

RESTAURANT:
- Name: ${restaurant.name}
- Cuisine: ${restaurant.cuisine_type || 'Restaurant'}
- Brand Color: ${restaurant.primary_color || '#2563eb'}
${reviewBlock}
PROMOTION DETAILS:
${promoText ? `- Offer: ${promoText}` : ''}
${eventName ? `- Event: ${eventName}` : ''}
${date ? `- Date: ${date}` : ''}

DESIGN REQUIREMENTS:
- ${style} and attention-grabbing design
- Restaurant name prominently displayed
- Promotion/event text large and readable
- Use brand color as primary accent
- Professional but exciting
- Clear call to action
- Suitable for print and digital use`;

    const outputPath = join(
      config.paths.images,
      `${restaurantId}_promo_${Date.now()}.png`
    );

    return this.generate(prompt, {
      aspectRatio: '4:5',
      outputPath
    });
  }

  /**
   * Generate a holiday/seasonal graphic
   */
  async generateHolidayGraphic(restaurantId, options = {}) {
    const {
      holiday = 'christmas',  // christmas, thanksgiving, valentines, newyear, etc.
      message = null
    } = options;

    const restaurant = RestaurantModel.getFullData(restaurantId);
    if (!restaurant) throw new Error('Restaurant not found');

    const holidayThemes = {
      christmas: 'festive Christmas theme with red, green, gold accents, snowflakes or ornaments',
      thanksgiving: 'warm autumn theme with orange, brown, harvest imagery',
      valentines: 'romantic theme with red, pink, hearts',
      newyear: 'celebration theme with gold, silver, champagne, fireworks',
      halloween: 'spooky fun theme with orange, black, purple',
      easter: 'spring theme with pastels, eggs, flowers',
      july4th: 'patriotic theme with red, white, blue, stars'
    };

    const reviewContext = this.getReviewContext(restaurantId);
    const reviewBlock = this.formatReviewPromptBlock(reviewContext);

    const prompt = `Create a ${holiday} holiday graphic for "${restaurant.name}".

RESTAURANT:
- Name: ${restaurant.name}
- Cuisine: ${restaurant.cuisine_type || 'Restaurant'}
- Brand Color: ${restaurant.primary_color || '#2563eb'}
${reviewBlock}
HOLIDAY STYLE:
${holidayThemes[holiday] || `${holiday} themed design`}

${message ? `MESSAGE TO INCLUDE: "${message}"` : `Include a warm ${holiday} greeting`}

DESIGN REQUIREMENTS:
- Festive and celebratory
- Restaurant name visible
- Holiday message prominent
- Blend holiday theme with restaurant brand
- Professional quality
- Suitable for social media and print`;

    const outputPath = join(
      config.paths.images,
      `${restaurantId}_${holiday}_${Date.now()}.png`
    );

    return this.generate(prompt, {
      aspectRatio: '1:1',
      outputPath
    });
  }

  /**
   * Generate a testimonial/review graphic featuring a customer quote
   */
  async generateTestimonialGraphic(restaurantId, options = {}) {
    const {
      platform = 'instagram',
      style = 'elegant',   // elegant | bold | minimal | warm
      quoteIndex = 0
    } = options;

    const restaurant = RestaurantModel.getFullData(restaurantId);
    if (!restaurant) throw new Error('Restaurant not found');

    const reviewContext = this.getReviewContext(restaurantId);
    if (!reviewContext.hasReviews || !reviewContext.bestQuotes || reviewContext.bestQuotes.length === 0) {
      throw new Error('No reviews available for this restaurant. Add reviews before generating a testimonial graphic.');
    }

    const idx = Math.min(quoteIndex, reviewContext.bestQuotes.length - 1);
    const quote = reviewContext.bestQuotes[idx];

    const styleDescriptions = {
      elegant: 'clean, elegant design with serif fonts, subtle background, and refined spacing',
      bold: 'bold, high-contrast design with large impactful typography and vibrant brand colors',
      minimal: 'minimal, modern design with plenty of whitespace and simple typography',
      warm: 'warm, inviting design with soft tones, rounded elements, and cozy feel'
    };

    const stars = '\u2605'.repeat(quote.rating) + '\u2606'.repeat(5 - quote.rating);

    const prompt = `Create a ${style} testimonial graphic for "${restaurant.name}".

QUOTE:
"${quote.text}"
— ${quote.author}
${stars}

RESTAURANT:
- Name: ${restaurant.name}
- Cuisine: ${restaurant.cuisine_type || 'Restaurant'}
- Brand Color: ${restaurant.primary_color || '#2563eb'}
- Google Rating: ${reviewContext.avgRating}/5 (${reviewContext.reviewCount} reviews)

DESIGN REQUIREMENTS:
- ${styleDescriptions[style] || styleDescriptions.elegant}
- Customer quote as the focal point, large and prominent
- Star rating displayed visually (${quote.rating}/5 stars)
- Author name below the quote
- Restaurant name and overall Google rating badge in corner
- Professional, trustworthy, and shareable
- Suitable for ${platform}`;

    const aspectRatios = {
      instagram: '1:1',
      facebook: '16:9',
      twitter: '16:9',
      story: '9:16'
    };

    const outputPath = join(
      config.paths.images,
      `${restaurantId}_testimonial_${style}_${Date.now()}.png`
    );

    return this.generate(prompt, {
      aspectRatio: aspectRatios[platform] || '1:1',
      outputPath
    });
  }

  /**
   * Get structured review context for a restaurant
   */
  getReviewContext(restaurantId) {
    try {
      const digest = ReviewDigestModel.getLatest(restaurantId);

      let avgRating, reviewCount, topPraiseThemes;

      if (digest && digest.reviewCount > 0) {
        avgRating = digest.avgRating;
        reviewCount = digest.reviewCount;
        topPraiseThemes = (digest.praiseThemes || []).slice(0, 3).map(p => p.theme);
      } else {
        const stats = ReviewModel.getStats(restaurantId);
        if (!stats || stats.total_reviews === 0) return { hasReviews: false };
        avgRating = stats.avg_rating;
        reviewCount = stats.total_reviews;
        topPraiseThemes = [];
      }

      // Pick best short quotes from positive reviews
      const positiveReviews = ReviewModel.getByRestaurant(restaurantId, {
        sentiment: 'positive',
        limit: 30
      });

      const bestQuotes = positiveReviews
        .filter(r => r.rating >= 4 && r.text && r.text.length >= 20 && r.text.length <= 200)
        .sort((a, b) => (b.sentimentScore || 0) - (a.sentimentScore || 0))
        .slice(0, 3)
        .map(r => ({ text: r.text, author: r.authorName || 'Customer', rating: r.rating }));

      return {
        hasReviews: true,
        avgRating: avgRating ? parseFloat(avgRating.toFixed(1)) : null,
        reviewCount,
        topPraiseThemes,
        bestQuotes
      };
    } catch (e) {
      return { hasReviews: false };
    }
  }

  /**
   * Format review context into a prompt block (empty string if no reviews)
   */
  formatReviewPromptBlock(ctx) {
    if (!ctx || !ctx.hasReviews) return '';

    let block = `\nCUSTOMER REVIEWS (use only when relevant — skip for closures, event-only announcements):`;

    if (ctx.avgRating && ctx.reviewCount) {
      block += `\n- Google Rating: ${ctx.avgRating}/5 (${ctx.reviewCount} reviews)`;
    }

    if (ctx.topPraiseThemes && ctx.topPraiseThemes.length > 0) {
      block += `\n- Customers love: ${ctx.topPraiseThemes.join(', ')}`;
    }

    if (ctx.bestQuotes && ctx.bestQuotes.length > 0) {
      block += `\n- Top quote: "${ctx.bestQuotes[0].text}" — ${ctx.bestQuotes[0].author}`;
    }

    block += '\n';
    return block;
  }

  /**
   * Build prompt for social media posts
   */
  buildSocialPrompt(restaurant, options) {
    const { platform, theme, customText, notes, reviewBlock = '' } = options;

    const themePrompts = {
      promotion: 'promotional post highlighting a special offer or the restaurant experience',
      announcement: `announcement post${notes.length > 0 ? ` about: ${notes[0].content}` : ''}`,
      'menu-highlight': 'post showcasing a signature dish or menu item',
      holiday: 'festive seasonal post'
    };

    return `Create a ${platform} social media graphic for "${restaurant.name}".

RESTAURANT:
- Name: ${restaurant.name}
- Cuisine: ${restaurant.cuisine_type || 'Restaurant'}
- Tagline: ${restaurant.tagline || ''}
- Brand Color: ${restaurant.primary_color || '#2563eb'}

POST TYPE: ${themePrompts[theme] || theme}
${reviewBlock}
${customText ? `TEXT TO INCLUDE: "${customText}"` : ''}

DESIGN REQUIREMENTS:
- Optimized for ${platform}
- Eye-catching and scroll-stopping
- Restaurant name/logo area
- Professional food/restaurant photography style
- Text overlay that's readable
- Brand colors incorporated
- Modern social media aesthetic
- ${restaurant.cuisine_type ? `Reflect ${restaurant.cuisine_type} cuisine vibes` : ''}`;
  }
}

/**
 * Convenience function to get generator instance
 */
export function createImageGenerator(usePro = false) {
  return new ImageGenerator({ pro: usePro });
}
